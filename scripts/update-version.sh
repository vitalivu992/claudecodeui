#!/bin/bash

# Version Update Script
# Updates package.json version, commits changes, and creates git tags

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output (to stderr in CI)
print_info() {
    if [[ -n "$CI" ]] || [[ -n "$GITHUB_ACTIONS" ]]; then
        echo -e "${BLUE}ℹ️  $1${NC}" >&2
    else
        echo -e "${BLUE}ℹ️  $1${NC}"
    fi
}

print_success() {
    if [[ -n "$CI" ]] || [[ -n "$GITHUB_ACTIONS" ]]; then
        echo -e "${GREEN}✅ $1${NC}" >&2
    else
        echo -e "${GREEN}✅ $1${NC}"
    fi
}

print_warning() {
    if [[ -n "$CI" ]] || [[ -n "$GITHUB_ACTIONS" ]]; then
        echo -e "${YELLOW}⚠️  $1${NC}" >&2
    else
        echo -e "${YELLOW}⚠️  $1${NC}"
    fi
}

print_error() {
    if [[ -n "$CI" ]] || [[ -n "$GITHUB_ACTIONS" ]]; then
        echo -e "${RED}❌ $1${NC}" >&2
    else
        echo -e "${RED}❌ $1${NC}"
    fi
}

# Function to update package.json version
update_package_version() {
    local new_version="$1"
    local version_type="$2"
    
    print_info "Updating package.json to version $new_version..."
    
    # Use npm version command to update package.json and package-lock.json
    npm version "$version_type" --no-git-tag-version
    
    print_success "Updated package.json to version $new_version"
}

# Function to commit version changes
commit_version_changes() {
    local new_version="$1"
    
    print_info "Committing version changes..."
    
    # Configure git if not already configured (for CI environments)
    if [[ -z "$(git config user.name 2>/dev/null)" ]]; then
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        print_info "Configured git user for CI environment"
    fi
    
    # Add changed files
    git add package.json package-lock.json
    
    # Check if there are changes to commit
    if git diff --staged --quiet; then
        print_warning "No changes to commit"
        return 0
    fi
    
    # Commit with conventional commit message
    git commit -m "chore: bump version to v$new_version [skip ci]"
    
    print_success "Committed version changes"
}

# Function to create and push git tag
create_and_push_tag() {
    local new_version="$1"
    local tag_name="v$new_version"
    
    print_info "Creating git tag: $tag_name"
    
    # Create annotated tag with release information
    git tag -a "$tag_name" -m "Release version $new_version

This release was automatically generated by semantic versioning.
See the GitHub release for detailed changelog."
    
    print_success "Created git tag: $tag_name"
    
    # Push tag to remote (only if not in dry-run mode)
    if [[ "${DRY_RUN:-false}" != "true" ]]; then
        print_info "Pushing tag to remote..."
        git push origin "$tag_name"
        print_success "Pushed tag to remote"
    else
        print_warning "DRY_RUN mode: skipping tag push"
    fi
}

# Function to generate changelog
generate_changelog() {
    local new_version="$1"
    local last_tag=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
    
    print_info "Generating changelog for v$new_version..."
    
    # Get commits since last release
    local commits
    if [[ -z "$last_tag" ]]; then
        commits=$(git log --pretty=format:"- %s (%h)" HEAD~10..HEAD 2>/dev/null || git log --pretty=format:"- %s (%h)" HEAD)
    else
        commits=$(git log --pretty=format:"- %s (%h)" ${last_tag}..HEAD)
    fi
    
    # Categorize commits
    local features=$(echo "$commits" | grep -E "^- feat(\(.+\))?:" || echo "")
    local fixes=$(echo "$commits" | grep -E "^- fix(\(.+\))?:" || echo "")
    local breaking=$(echo "$commits" | grep -E "^- [a-zA-Z]+(\(.+\))?!:|BREAKING CHANGE:" || echo "")
    local other=$(echo "$commits" | grep -vE "^- (feat|fix)(\(.+\))?:" | grep -vE "^- [a-zA-Z]+(\(.+\))?!:" || echo "")
    
    # Build changelog
    local changelog="## Changes in v$new_version"
    
    if [[ -n "$breaking" ]]; then
        changelog="$changelog

### 🚨 Breaking Changes
$breaking"
    fi
    
    if [[ -n "$features" ]]; then
        changelog="$changelog

### ✨ New Features  
$features"
    fi
    
    if [[ -n "$fixes" ]]; then
        changelog="$changelog

### 🐛 Bug Fixes
$fixes"
    fi
    
    if [[ -n "$other" ]]; then
        changelog="$changelog

### 🔧 Other Changes
$other"
    fi
    
    changelog="$changelog

### 📦 Installation
\`\`\`bash
npx @vitalivu992/claude-code-ui@$new_version --registry=https://npm.pkg.github.com
\`\`\`

### 🔗 GitHub Package Registry
\`\`\`bash
npm install @vitalivu992/claude-code-ui@$new_version --registry=https://npm.pkg.github.com
\`\`\`"
    
    # Save changelog to file
    echo "$changelog" > "RELEASE_NOTES_v$new_version.md"
    
    print_success "Generated changelog: RELEASE_NOTES_v$new_version.md"
    
    # Set GitHub Actions output
    if [[ -n "$GITHUB_ENV" ]]; then
        echo "CHANGELOG_FILE=RELEASE_NOTES_v$new_version.md" >> "$GITHUB_ENV"
    fi
}

# Main function
main() {
    local new_version=""
    local version_type=""
    local dry_run=false
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --version)
                new_version="$2"
                shift 2
                ;;
            --type)
                version_type="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                export DRY_RUN=true
                shift
                ;;
            --help|-h)
                echo "Usage: $0 --version VERSION --type TYPE [--dry-run]"
                echo ""
                echo "Options:"
                echo "  --version VERSION  New version to set (e.g., 1.2.3)"
                echo "  --type TYPE        Version bump type (patch|minor|major)"
                echo "  --dry-run          Don't push changes to remote"
                echo "  --help, -h         Show this help message"
                echo ""
                echo "Examples:"
                echo "  $0 --version 1.2.3 --type minor"
                echo "  $0 --version 1.0.1 --type patch --dry-run"
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$new_version" ]]; then
        print_error "Version is required. Use --version to specify."
        exit 1
    fi
    
    if [[ -z "$version_type" ]]; then
        print_error "Version type is required. Use --type to specify (patch|minor|major)."
        exit 1
    fi
    
    print_info "🚀 Starting version update process..."
    
    if [[ "$dry_run" == "true" ]]; then
        print_warning "DRY_RUN mode enabled - no remote changes will be made"
    fi
    
    # Ensure we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Not in a git repository"
        exit 1
    fi
    
    # Check if working directory is clean
    if [[ -n "$(git status --porcelain)" ]]; then
        print_warning "Working directory is not clean. Uncommitted changes:"
        git status --short
        print_info "Continuing anyway..."
    fi
    
    # Update package version
    update_package_version "$new_version" "$version_type"
    
    # Commit changes
    commit_version_changes "$new_version"
    
    # Generate changelog
    generate_changelog "$new_version"
    
    # Create and push tag
    create_and_push_tag "$new_version"
    
    print_success "🎉 Version update complete!"
    print_info "New version: $new_version"
    print_info "Git tag: v$new_version"
    
    if [[ "$dry_run" == "true" ]]; then
        print_warning "DRY_RUN mode: Remember to push changes manually"
        print_info "To push: git push origin v$new_version"
    fi
}

# Run main function with all arguments
main "$@"
